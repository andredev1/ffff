{"ast":null,"code":"import { CandleList } from '../StockData';\nimport { atr } from '../directionalmovement/ATR';\n/**\n * Created by AAravindan on 5/4/16.\n */\n\nimport { Indicator, IndicatorInput } from '../indicator/indicator';\nexport class RenkoInput extends IndicatorInput {}\n\nclass Renko extends Indicator {\n  constructor(input) {\n    super(input);\n    var format = this.format;\n    let useATR = input.useATR;\n    let brickSize = input.brickSize || 0;\n\n    if (useATR) {\n      let atrResult = atr(Object.assign({}, input));\n      brickSize = atrResult[atrResult.length - 1];\n    }\n\n    this.result = new CandleList();\n    ;\n\n    if (brickSize === 0) {\n      console.error('Not enough data to calculate brickSize for renko when using ATR');\n      return;\n    }\n\n    let lastOpen = 0;\n    let lastHigh = 0;\n    let lastLow = Infinity;\n    let lastClose = 0;\n    let lastVolume = 0;\n    let lastTimestamp = 0;\n\n    this.generator = function* () {\n      let candleData = yield;\n\n      while (true) {\n        //Calculating first bar\n        if (lastOpen === 0) {\n          lastOpen = candleData.close;\n          lastHigh = candleData.high;\n          lastLow = candleData.low;\n          lastClose = candleData.close;\n          lastVolume = candleData.volume;\n          lastTimestamp = candleData.timestamp;\n          candleData = yield;\n          continue;\n        }\n\n        let absoluteMovementFromClose = Math.abs(candleData.close - lastClose);\n        let absoluteMovementFromOpen = Math.abs(candleData.close - lastOpen);\n\n        if (absoluteMovementFromClose >= brickSize && absoluteMovementFromOpen >= brickSize) {\n          let reference = absoluteMovementFromClose > absoluteMovementFromOpen ? lastOpen : lastClose;\n          let calculated = {\n            open: reference,\n            high: lastHigh > candleData.high ? lastHigh : candleData.high,\n            low: lastLow < candleData.Low ? lastLow : candleData.low,\n            close: reference > candleData.close ? reference - brickSize : reference + brickSize,\n            volume: lastVolume + candleData.volume,\n            timestamp: candleData.timestamp\n          };\n          lastOpen = calculated.open;\n          lastHigh = calculated.close;\n          lastLow = calculated.close;\n          lastClose = calculated.close;\n          lastVolume = 0;\n          candleData = yield calculated;\n        } else {\n          lastHigh = lastHigh > candleData.high ? lastHigh : candleData.high;\n          lastLow = lastLow < candleData.Low ? lastLow : candleData.low;\n          lastVolume = lastVolume + candleData.volume;\n          lastTimestamp = candleData.timestamp;\n          candleData = yield;\n        }\n      }\n    }();\n\n    this.generator.next();\n    input.low.forEach((tick, index) => {\n      var result = this.generator.next({\n        open: input.open[index],\n        high: input.high[index],\n        low: input.low[index],\n        close: input.close[index],\n        volume: input.volume[index],\n        timestamp: input.timestamp[index]\n      });\n\n      if (result.value) {\n        this.result.open.push(result.value.open);\n        this.result.high.push(result.value.high);\n        this.result.low.push(result.value.low);\n        this.result.close.push(result.value.close);\n        this.result.volume.push(result.value.volume);\n        this.result.timestamp.push(result.value.timestamp);\n      }\n    });\n  }\n\n  nextValue(price) {\n    console.error('Cannot calculate next value on Renko, Every value has to be recomputed for every change, use calcualte method');\n    return null;\n  }\n\n}\n\nRenko.calculate = renko;\nexport function renko(input) {\n  Indicator.reverseInputs(input);\n  var result = new Renko(input).result;\n\n  if (input.reversedInput) {\n    result.open.reverse();\n    result.high.reverse();\n    result.low.reverse();\n    result.close.reverse();\n    result.volume.reverse();\n    result.timestamp.reverse();\n  }\n\n  Indicator.reverseInputs(input);\n  return result;\n}\n;","map":{"version":3,"sources":["/home/andre/ffff/node_modules/technicalindicators/lib/chart_types/Renko.js"],"names":["CandleList","atr","Indicator","IndicatorInput","RenkoInput","Renko","constructor","input","format","useATR","brickSize","atrResult","Object","assign","length","result","console","error","lastOpen","lastHigh","lastLow","Infinity","lastClose","lastVolume","lastTimestamp","generator","candleData","close","high","low","volume","timestamp","absoluteMovementFromClose","Math","abs","absoluteMovementFromOpen","reference","calculated","open","Low","next","forEach","tick","index","value","push","nextValue","price","calculate","renko","reverseInputs","reversedInput","reverse"],"mappings":"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","sourcesContent":["import { CandleList } from '../StockData';\nimport { atr } from '../directionalmovement/ATR';\n/**\n * Created by AAravindan on 5/4/16.\n */\nimport { Indicator, IndicatorInput } from '../indicator/indicator';\nexport class RenkoInput extends IndicatorInput {\n}\nclass Renko extends Indicator {\n    constructor(input) {\n        super(input);\n        var format = this.format;\n        let useATR = input.useATR;\n        let brickSize = input.brickSize || 0;\n        if (useATR) {\n            let atrResult = atr(Object.assign({}, input));\n            brickSize = atrResult[atrResult.length - 1];\n        }\n        this.result = new CandleList();\n        ;\n        if (brickSize === 0) {\n            console.error('Not enough data to calculate brickSize for renko when using ATR');\n            return;\n        }\n        let lastOpen = 0;\n        let lastHigh = 0;\n        let lastLow = Infinity;\n        let lastClose = 0;\n        let lastVolume = 0;\n        let lastTimestamp = 0;\n        this.generator = (function* () {\n            let candleData = yield;\n            while (true) {\n                //Calculating first bar\n                if (lastOpen === 0) {\n                    lastOpen = candleData.close;\n                    lastHigh = candleData.high;\n                    lastLow = candleData.low;\n                    lastClose = candleData.close;\n                    lastVolume = candleData.volume;\n                    lastTimestamp = candleData.timestamp;\n                    candleData = yield;\n                    continue;\n                }\n                let absoluteMovementFromClose = Math.abs(candleData.close - lastClose);\n                let absoluteMovementFromOpen = Math.abs(candleData.close - lastOpen);\n                if ((absoluteMovementFromClose >= brickSize) && (absoluteMovementFromOpen >= brickSize)) {\n                    let reference = absoluteMovementFromClose > absoluteMovementFromOpen ? lastOpen : lastClose;\n                    let calculated = {\n                        open: reference,\n                        high: lastHigh > candleData.high ? lastHigh : candleData.high,\n                        low: lastLow < candleData.Low ? lastLow : candleData.low,\n                        close: reference > candleData.close ? (reference - brickSize) : (reference + brickSize),\n                        volume: lastVolume + candleData.volume,\n                        timestamp: candleData.timestamp\n                    };\n                    lastOpen = calculated.open;\n                    lastHigh = calculated.close;\n                    lastLow = calculated.close;\n                    lastClose = calculated.close;\n                    lastVolume = 0;\n                    candleData = yield calculated;\n                }\n                else {\n                    lastHigh = lastHigh > candleData.high ? lastHigh : candleData.high;\n                    lastLow = lastLow < candleData.Low ? lastLow : candleData.low;\n                    lastVolume = lastVolume + candleData.volume;\n                    lastTimestamp = candleData.timestamp;\n                    candleData = yield;\n                }\n            }\n        })();\n        this.generator.next();\n        input.low.forEach((tick, index) => {\n            var result = this.generator.next({\n                open: input.open[index],\n                high: input.high[index],\n                low: input.low[index],\n                close: input.close[index],\n                volume: input.volume[index],\n                timestamp: input.timestamp[index]\n            });\n            if (result.value) {\n                this.result.open.push(result.value.open);\n                this.result.high.push(result.value.high);\n                this.result.low.push(result.value.low);\n                this.result.close.push(result.value.close);\n                this.result.volume.push(result.value.volume);\n                this.result.timestamp.push(result.value.timestamp);\n            }\n        });\n    }\n    nextValue(price) {\n        console.error('Cannot calculate next value on Renko, Every value has to be recomputed for every change, use calcualte method');\n        return null;\n    }\n    ;\n}\nRenko.calculate = renko;\nexport function renko(input) {\n    Indicator.reverseInputs(input);\n    var result = new Renko(input).result;\n    if (input.reversedInput) {\n        result.open.reverse();\n        result.high.reverse();\n        result.low.reverse();\n        result.close.reverse();\n        result.volume.reverse();\n        result.timestamp.reverse();\n    }\n    Indicator.reverseInputs(input);\n    return result;\n}\n;\n"]},"metadata":{},"sourceType":"module"}