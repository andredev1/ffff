{"ast":null,"code":"import { Indicator, IndicatorInput } from '../indicator/indicator';\nimport { SMA } from '../moving_averages/SMA';\nimport LinkedList from '../Utils/FixedSizeLinkedList';\nexport class CCIInput extends IndicatorInput {}\n;\nexport class CCI extends Indicator {\n  constructor(input) {\n    super(input);\n    var lows = input.low;\n    var highs = input.high;\n    var closes = input.close;\n    var period = input.period;\n    var format = this.format;\n    let constant = .015;\n    var currentTpSet = new LinkedList(period);\n    ;\n    var tpSMACalculator = new SMA({\n      period: period,\n      values: [],\n      format: v => {\n        return v;\n      }\n    });\n\n    if (!(lows.length === highs.length && highs.length === closes.length)) {\n      throw 'Inputs(low,high, close) not of equal size';\n    }\n\n    this.result = [];\n\n    this.generator = function* () {\n      var tick = yield;\n\n      while (true) {\n        let tp = (tick.high + tick.low + tick.close) / 3;\n        currentTpSet.push(tp);\n        let smaTp = tpSMACalculator.nextValue(tp);\n        let meanDeviation = null;\n        let cci;\n        let sum = 0;\n\n        if (smaTp != undefined) {\n          //First, subtract the most recent 20-period average of the typical price from each period's typical price. \n          //Second, take the absolute values of these numbers.\n          //Third,sum the absolute values. \n          for (let x of currentTpSet.iterator()) {\n            sum = sum + Math.abs(x - smaTp);\n          } //Fourth, divide by the total number of periods (20). \n\n\n          meanDeviation = sum / period;\n          cci = (tp - smaTp) / (constant * meanDeviation);\n        }\n\n        tick = yield cci;\n      }\n    }();\n\n    this.generator.next();\n    lows.forEach((tick, index) => {\n      var result = this.generator.next({\n        high: highs[index],\n        low: lows[index],\n        close: closes[index]\n      });\n\n      if (result.value != undefined) {\n        this.result.push(result.value);\n      }\n    });\n  }\n\n  nextValue(price) {\n    let result = this.generator.next(price).value;\n\n    if (result != undefined) {\n      return result;\n    }\n  }\n\n}\nCCI.calculate = cci;\nexport function cci(input) {\n  Indicator.reverseInputs(input);\n  var result = new CCI(input).result;\n\n  if (input.reversedInput) {\n    result.reverse();\n  }\n\n  Indicator.reverseInputs(input);\n  return result;\n}\n;","map":{"version":3,"sources":["/home/andre/Documents/ffff/node_modules/technicalindicators/lib/oscillators/CCI.js"],"names":["Indicator","IndicatorInput","SMA","LinkedList","CCIInput","CCI","constructor","input","lows","low","highs","high","closes","close","period","format","constant","currentTpSet","tpSMACalculator","values","v","length","result","generator","tick","tp","push","smaTp","nextValue","meanDeviation","cci","sum","undefined","x","iterator","Math","abs","next","forEach","index","value","price","calculate","reverseInputs","reversedInput","reverse"],"mappings":"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","sourcesContent":["import { Indicator, IndicatorInput } from '../indicator/indicator';\nimport { SMA } from '../moving_averages/SMA';\nimport LinkedList from '../Utils/FixedSizeLinkedList';\nexport class CCIInput extends IndicatorInput {\n}\n;\nexport class CCI extends Indicator {\n    constructor(input) {\n        super(input);\n        var lows = input.low;\n        var highs = input.high;\n        var closes = input.close;\n        var period = input.period;\n        var format = this.format;\n        let constant = .015;\n        var currentTpSet = new LinkedList(period);\n        ;\n        var tpSMACalculator = new SMA({ period: period, values: [], format: (v) => { return v; } });\n        if (!((lows.length === highs.length) && (highs.length === closes.length))) {\n            throw ('Inputs(low,high, close) not of equal size');\n        }\n        this.result = [];\n        this.generator = (function* () {\n            var tick = yield;\n            while (true) {\n                let tp = (tick.high + tick.low + tick.close) / 3;\n                currentTpSet.push(tp);\n                let smaTp = tpSMACalculator.nextValue(tp);\n                let meanDeviation = null;\n                let cci;\n                let sum = 0;\n                if (smaTp != undefined) {\n                    //First, subtract the most recent 20-period average of the typical price from each period's typical price. \n                    //Second, take the absolute values of these numbers.\n                    //Third,sum the absolute values. \n                    for (let x of currentTpSet.iterator()) {\n                        sum = sum + (Math.abs(x - smaTp));\n                    }\n                    //Fourth, divide by the total number of periods (20). \n                    meanDeviation = sum / period;\n                    cci = (tp - smaTp) / (constant * meanDeviation);\n                }\n                tick = yield cci;\n            }\n        })();\n        this.generator.next();\n        lows.forEach((tick, index) => {\n            var result = this.generator.next({\n                high: highs[index],\n                low: lows[index],\n                close: closes[index]\n            });\n            if (result.value != undefined) {\n                this.result.push(result.value);\n            }\n        });\n    }\n    ;\n    ;\n    nextValue(price) {\n        let result = this.generator.next(price).value;\n        if (result != undefined) {\n            return result;\n        }\n    }\n    ;\n}\nCCI.calculate = cci;\nexport function cci(input) {\n    Indicator.reverseInputs(input);\n    var result = new CCI(input).result;\n    if (input.reversedInput) {\n        result.reverse();\n    }\n    Indicator.reverseInputs(input);\n    return result;\n}\n;\n"]},"metadata":{},"sourceType":"module"}