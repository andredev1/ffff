{"ast":null,"code":"import { Indicator, IndicatorInput } from '../indicator/indicator';\nexport class CrossInput extends IndicatorInput {\n  constructor(lineA, lineB) {\n    super();\n    this.lineA = lineA;\n    this.lineB = lineB;\n  }\n\n}\nexport class CrossUp extends Indicator {\n  constructor(input) {\n    super(input);\n    this.lineA = input.lineA;\n    this.lineB = input.lineB;\n    var currentLineA = [];\n    var currentLineB = [];\n\n    const genFn = function* () {\n      var current = yield;\n      var result = false;\n\n      while (true) {\n        currentLineA.unshift(current.valueA);\n        currentLineB.unshift(current.valueB);\n        result = current.valueA > current.valueB;\n        var pointer = 1;\n\n        while (result === true && currentLineA[pointer] >= currentLineB[pointer]) {\n          if (currentLineA[pointer] > currentLineB[pointer]) {\n            result = false;\n          } else if (currentLineA[pointer] < currentLineB[pointer]) {\n            result = true;\n          } else if (currentLineA[pointer] === currentLineB[pointer]) {\n            pointer += 1;\n          }\n        }\n\n        if (result === true) {\n          currentLineA = [current.valueA];\n          currentLineB = [current.valueB];\n        }\n\n        current = yield result;\n      }\n    };\n\n    this.generator = genFn();\n    this.generator.next();\n    this.result = [];\n    this.lineA.forEach((value, index) => {\n      var result = this.generator.next({\n        valueA: this.lineA[index],\n        valueB: this.lineB[index]\n      });\n\n      if (result.value !== undefined) {\n        this.result.push(result.value);\n      }\n    });\n  }\n\n  static reverseInputs(input) {\n    if (input.reversedInput) {\n      input.lineA ? input.lineA.reverse() : undefined;\n      input.lineB ? input.lineB.reverse() : undefined;\n    }\n  }\n\n  nextValue(valueA, valueB) {\n    return this.generator.next({\n      valueA: valueA,\n      valueB: valueB\n    }).value;\n  }\n\n}\nCrossUp.calculate = crossUp;\nexport function crossUp(input) {\n  Indicator.reverseInputs(input);\n  var result = new CrossUp(input).result;\n\n  if (input.reversedInput) {\n    result.reverse();\n  }\n\n  Indicator.reverseInputs(input);\n  return result;\n}","map":{"version":3,"sources":["/home/andre/Downloads/ffff-main/node_modules/technicalindicators/lib/Utils/CrossUp.js"],"names":["Indicator","IndicatorInput","CrossInput","constructor","lineA","lineB","CrossUp","input","currentLineA","currentLineB","genFn","current","result","unshift","valueA","valueB","pointer","generator","next","forEach","value","index","undefined","push","reverseInputs","reversedInput","reverse","nextValue","calculate","crossUp"],"mappings":"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","sourcesContent":["import { Indicator, IndicatorInput } from '../indicator/indicator';\nexport class CrossInput extends IndicatorInput {\n    constructor(lineA, lineB) {\n        super();\n        this.lineA = lineA;\n        this.lineB = lineB;\n    }\n}\nexport class CrossUp extends Indicator {\n    constructor(input) {\n        super(input);\n        this.lineA = input.lineA;\n        this.lineB = input.lineB;\n        var currentLineA = [];\n        var currentLineB = [];\n        const genFn = (function* () {\n            var current = yield;\n            var result = false;\n            while (true) {\n                currentLineA.unshift(current.valueA);\n                currentLineB.unshift(current.valueB);\n                result = current.valueA > current.valueB;\n                var pointer = 1;\n                while (result === true && currentLineA[pointer] >= currentLineB[pointer]) {\n                    if (currentLineA[pointer] > currentLineB[pointer]) {\n                        result = false;\n                    }\n                    else if (currentLineA[pointer] < currentLineB[pointer]) {\n                        result = true;\n                    }\n                    else if (currentLineA[pointer] === currentLineB[pointer]) {\n                        pointer += 1;\n                    }\n                }\n                if (result === true) {\n                    currentLineA = [current.valueA];\n                    currentLineB = [current.valueB];\n                }\n                current = yield result;\n            }\n        });\n        this.generator = genFn();\n        this.generator.next();\n        this.result = [];\n        this.lineA.forEach((value, index) => {\n            var result = this.generator.next({\n                valueA: this.lineA[index],\n                valueB: this.lineB[index]\n            });\n            if (result.value !== undefined) {\n                this.result.push(result.value);\n            }\n        });\n    }\n    static reverseInputs(input) {\n        if (input.reversedInput) {\n            input.lineA ? input.lineA.reverse() : undefined;\n            input.lineB ? input.lineB.reverse() : undefined;\n        }\n    }\n    nextValue(valueA, valueB) {\n        return this.generator.next({\n            valueA: valueA,\n            valueB: valueB\n        }).value;\n    }\n    ;\n}\nCrossUp.calculate = crossUp;\nexport function crossUp(input) {\n    Indicator.reverseInputs(input);\n    var result = new CrossUp(input).result;\n    if (input.reversedInput) {\n        result.reverse();\n    }\n    Indicator.reverseInputs(input);\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}