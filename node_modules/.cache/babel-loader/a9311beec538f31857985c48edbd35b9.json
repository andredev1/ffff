{"ast":null,"code":"export default class CandlestickFinder {\n  constructor() {// if (new.target === Abstract) {\n    //     throw new TypeError(\"Abstract class\");\n    // }\n  }\n\n  approximateEqual(a, b) {\n    let left = parseFloat(Math.abs(a - b).toPrecision(4)) * 1;\n    let right = parseFloat((a * 0.001).toPrecision(4)) * 1;\n    return left <= right;\n  }\n\n  logic(data) {\n    throw \"this has to be implemented\";\n  }\n\n  getAllPatternIndex(data) {\n    if (data.close.length < this.requiredCount) {\n      console.warn('Data count less than data required for the strategy ', this.name);\n      return [];\n    }\n\n    if (data.reversedInput) {\n      data.open.reverse();\n      data.high.reverse();\n      data.low.reverse();\n      data.close.reverse();\n    }\n\n    let strategyFn = this.logic;\n    return this._generateDataForCandleStick(data).map((current, index) => {\n      return strategyFn.call(this, current) ? index : undefined;\n    }).filter(hasIndex => {\n      return hasIndex;\n    });\n  }\n\n  hasPattern(data) {\n    if (data.close.length < this.requiredCount) {\n      console.warn('Data count less than data required for the strategy ', this.name);\n      return false;\n    }\n\n    if (data.reversedInput) {\n      data.open.reverse();\n      data.high.reverse();\n      data.low.reverse();\n      data.close.reverse();\n    }\n\n    let strategyFn = this.logic;\n    return strategyFn.call(this, this._getLastDataForCandleStick(data));\n  }\n\n  _getLastDataForCandleStick(data) {\n    let requiredCount = this.requiredCount;\n\n    if (data.close.length === requiredCount) {\n      return data;\n    } else {\n      let returnVal = {\n        open: [],\n        high: [],\n        low: [],\n        close: []\n      };\n      let i = 0;\n      let index = data.close.length - requiredCount;\n\n      while (i < requiredCount) {\n        returnVal.open.push(data.open[index + i]);\n        returnVal.high.push(data.high[index + i]);\n        returnVal.low.push(data.low[index + i]);\n        returnVal.close.push(data.close[index + i]);\n        i++;\n      }\n\n      return returnVal;\n    }\n  }\n\n  _generateDataForCandleStick(data) {\n    let requiredCount = this.requiredCount;\n    let generatedData = data.close.map(function (currentData, index) {\n      let i = 0;\n      let returnVal = {\n        open: [],\n        high: [],\n        low: [],\n        close: []\n      };\n\n      while (i < requiredCount) {\n        returnVal.open.push(data.open[index + i]);\n        returnVal.high.push(data.high[index + i]);\n        returnVal.low.push(data.low[index + i]);\n        returnVal.close.push(data.close[index + i]);\n        i++;\n      }\n\n      return returnVal;\n    }).filter((val, index) => {\n      return index <= data.close.length - requiredCount;\n    });\n    return generatedData;\n  }\n\n}","map":{"version":3,"sources":["/home/andre/Documents/f/f/node_modules/technicalindicators/lib/candlestick/CandlestickFinder.js"],"names":["CandlestickFinder","constructor","approximateEqual","a","b","left","parseFloat","Math","abs","toPrecision","right","logic","data","getAllPatternIndex","close","length","requiredCount","console","warn","name","reversedInput","open","reverse","high","low","strategyFn","_generateDataForCandleStick","map","current","index","call","undefined","filter","hasIndex","hasPattern","_getLastDataForCandleStick","returnVal","i","push","generatedData","currentData","val"],"mappings":"AAAA,eAAe,MAAMA,iBAAN,CAAwB;AACnCC,EAAAA,WAAW,GAAG,CACV;AACA;AACA;AACH;;AACDC,EAAAA,gBAAgB,CAACC,CAAD,EAAIC,CAAJ,EAAO;AACnB,QAAIC,IAAI,GAAGC,UAAU,CAACC,IAAI,CAACC,GAAL,CAASL,CAAC,GAAGC,CAAb,EAAgBK,WAAhB,CAA4B,CAA5B,CAAD,CAAV,GAA6C,CAAxD;AACA,QAAIC,KAAK,GAAGJ,UAAU,CAAC,CAACH,CAAC,GAAG,KAAL,EAAYM,WAAZ,CAAwB,CAAxB,CAAD,CAAV,GAAyC,CAArD;AACA,WAAOJ,IAAI,IAAIK,KAAf;AACH;;AACDC,EAAAA,KAAK,CAACC,IAAD,EAAO;AACR,UAAM,4BAAN;AACH;;AACDC,EAAAA,kBAAkB,CAACD,IAAD,EAAO;AACrB,QAAIA,IAAI,CAACE,KAAL,CAAWC,MAAX,GAAoB,KAAKC,aAA7B,EAA4C;AACxCC,MAAAA,OAAO,CAACC,IAAR,CAAa,sDAAb,EAAqE,KAAKC,IAA1E;AACA,aAAO,EAAP;AACH;;AACD,QAAIP,IAAI,CAACQ,aAAT,EAAwB;AACpBR,MAAAA,IAAI,CAACS,IAAL,CAAUC,OAAV;AACAV,MAAAA,IAAI,CAACW,IAAL,CAAUD,OAAV;AACAV,MAAAA,IAAI,CAACY,GAAL,CAASF,OAAT;AACAV,MAAAA,IAAI,CAACE,KAAL,CAAWQ,OAAX;AACH;;AACD,QAAIG,UAAU,GAAG,KAAKd,KAAtB;AACA,WAAO,KAAKe,2BAAL,CAAiCd,IAAjC,EACFe,GADE,CACE,CAACC,OAAD,EAAUC,KAAV,KAAoB;AACzB,aAAOJ,UAAU,CAACK,IAAX,CAAgB,IAAhB,EAAsBF,OAAtB,IAAiCC,KAAjC,GAAyCE,SAAhD;AACH,KAHM,EAGJC,MAHI,CAGIC,QAAD,IAAc;AACpB,aAAOA,QAAP;AACH,KALM,CAAP;AAMH;;AACDC,EAAAA,UAAU,CAACtB,IAAD,EAAO;AACb,QAAIA,IAAI,CAACE,KAAL,CAAWC,MAAX,GAAoB,KAAKC,aAA7B,EAA4C;AACxCC,MAAAA,OAAO,CAACC,IAAR,CAAa,sDAAb,EAAqE,KAAKC,IAA1E;AACA,aAAO,KAAP;AACH;;AACD,QAAIP,IAAI,CAACQ,aAAT,EAAwB;AACpBR,MAAAA,IAAI,CAACS,IAAL,CAAUC,OAAV;AACAV,MAAAA,IAAI,CAACW,IAAL,CAAUD,OAAV;AACAV,MAAAA,IAAI,CAACY,GAAL,CAASF,OAAT;AACAV,MAAAA,IAAI,CAACE,KAAL,CAAWQ,OAAX;AACH;;AACD,QAAIG,UAAU,GAAG,KAAKd,KAAtB;AACA,WAAOc,UAAU,CAACK,IAAX,CAAgB,IAAhB,EAAsB,KAAKK,0BAAL,CAAgCvB,IAAhC,CAAtB,CAAP;AACH;;AACDuB,EAAAA,0BAA0B,CAACvB,IAAD,EAAO;AAC7B,QAAII,aAAa,GAAG,KAAKA,aAAzB;;AACA,QAAIJ,IAAI,CAACE,KAAL,CAAWC,MAAX,KAAsBC,aAA1B,EAAyC;AACrC,aAAOJ,IAAP;AACH,KAFD,MAGK;AACD,UAAIwB,SAAS,GAAG;AACZf,QAAAA,IAAI,EAAE,EADM;AAEZE,QAAAA,IAAI,EAAE,EAFM;AAGZC,QAAAA,GAAG,EAAE,EAHO;AAIZV,QAAAA,KAAK,EAAE;AAJK,OAAhB;AAMA,UAAIuB,CAAC,GAAG,CAAR;AACA,UAAIR,KAAK,GAAGjB,IAAI,CAACE,KAAL,CAAWC,MAAX,GAAoBC,aAAhC;;AACA,aAAOqB,CAAC,GAAGrB,aAAX,EAA0B;AACtBoB,QAAAA,SAAS,CAACf,IAAV,CAAeiB,IAAf,CAAoB1B,IAAI,CAACS,IAAL,CAAUQ,KAAK,GAAGQ,CAAlB,CAApB;AACAD,QAAAA,SAAS,CAACb,IAAV,CAAee,IAAf,CAAoB1B,IAAI,CAACW,IAAL,CAAUM,KAAK,GAAGQ,CAAlB,CAApB;AACAD,QAAAA,SAAS,CAACZ,GAAV,CAAcc,IAAd,CAAmB1B,IAAI,CAACY,GAAL,CAASK,KAAK,GAAGQ,CAAjB,CAAnB;AACAD,QAAAA,SAAS,CAACtB,KAAV,CAAgBwB,IAAhB,CAAqB1B,IAAI,CAACE,KAAL,CAAWe,KAAK,GAAGQ,CAAnB,CAArB;AACAA,QAAAA,CAAC;AACJ;;AACD,aAAOD,SAAP;AACH;AACJ;;AACDV,EAAAA,2BAA2B,CAACd,IAAD,EAAO;AAC9B,QAAII,aAAa,GAAG,KAAKA,aAAzB;AACA,QAAIuB,aAAa,GAAG3B,IAAI,CAACE,KAAL,CAAWa,GAAX,CAAe,UAAUa,WAAV,EAAuBX,KAAvB,EAA8B;AAC7D,UAAIQ,CAAC,GAAG,CAAR;AACA,UAAID,SAAS,GAAG;AACZf,QAAAA,IAAI,EAAE,EADM;AAEZE,QAAAA,IAAI,EAAE,EAFM;AAGZC,QAAAA,GAAG,EAAE,EAHO;AAIZV,QAAAA,KAAK,EAAE;AAJK,OAAhB;;AAMA,aAAOuB,CAAC,GAAGrB,aAAX,EAA0B;AACtBoB,QAAAA,SAAS,CAACf,IAAV,CAAeiB,IAAf,CAAoB1B,IAAI,CAACS,IAAL,CAAUQ,KAAK,GAAGQ,CAAlB,CAApB;AACAD,QAAAA,SAAS,CAACb,IAAV,CAAee,IAAf,CAAoB1B,IAAI,CAACW,IAAL,CAAUM,KAAK,GAAGQ,CAAlB,CAApB;AACAD,QAAAA,SAAS,CAACZ,GAAV,CAAcc,IAAd,CAAmB1B,IAAI,CAACY,GAAL,CAASK,KAAK,GAAGQ,CAAjB,CAAnB;AACAD,QAAAA,SAAS,CAACtB,KAAV,CAAgBwB,IAAhB,CAAqB1B,IAAI,CAACE,KAAL,CAAWe,KAAK,GAAGQ,CAAnB,CAArB;AACAA,QAAAA,CAAC;AACJ;;AACD,aAAOD,SAAP;AACH,KAhBmB,EAgBjBJ,MAhBiB,CAgBV,CAACS,GAAD,EAAMZ,KAAN,KAAgB;AAAE,aAAQA,KAAK,IAAKjB,IAAI,CAACE,KAAL,CAAWC,MAAX,GAAoBC,aAAtC;AAAwD,KAhBhE,CAApB;AAiBA,WAAOuB,aAAP;AACH;;AA3FkC","sourcesContent":["export default class CandlestickFinder {\n    constructor() {\n        // if (new.target === Abstract) {\n        //     throw new TypeError(\"Abstract class\");\n        // }\n    }\n    approximateEqual(a, b) {\n        let left = parseFloat(Math.abs(a - b).toPrecision(4)) * 1;\n        let right = parseFloat((a * 0.001).toPrecision(4)) * 1;\n        return left <= right;\n    }\n    logic(data) {\n        throw \"this has to be implemented\";\n    }\n    getAllPatternIndex(data) {\n        if (data.close.length < this.requiredCount) {\n            console.warn('Data count less than data required for the strategy ', this.name);\n            return [];\n        }\n        if (data.reversedInput) {\n            data.open.reverse();\n            data.high.reverse();\n            data.low.reverse();\n            data.close.reverse();\n        }\n        let strategyFn = this.logic;\n        return this._generateDataForCandleStick(data)\n            .map((current, index) => {\n            return strategyFn.call(this, current) ? index : undefined;\n        }).filter((hasIndex) => {\n            return hasIndex;\n        });\n    }\n    hasPattern(data) {\n        if (data.close.length < this.requiredCount) {\n            console.warn('Data count less than data required for the strategy ', this.name);\n            return false;\n        }\n        if (data.reversedInput) {\n            data.open.reverse();\n            data.high.reverse();\n            data.low.reverse();\n            data.close.reverse();\n        }\n        let strategyFn = this.logic;\n        return strategyFn.call(this, this._getLastDataForCandleStick(data));\n    }\n    _getLastDataForCandleStick(data) {\n        let requiredCount = this.requiredCount;\n        if (data.close.length === requiredCount) {\n            return data;\n        }\n        else {\n            let returnVal = {\n                open: [],\n                high: [],\n                low: [],\n                close: []\n            };\n            let i = 0;\n            let index = data.close.length - requiredCount;\n            while (i < requiredCount) {\n                returnVal.open.push(data.open[index + i]);\n                returnVal.high.push(data.high[index + i]);\n                returnVal.low.push(data.low[index + i]);\n                returnVal.close.push(data.close[index + i]);\n                i++;\n            }\n            return returnVal;\n        }\n    }\n    _generateDataForCandleStick(data) {\n        let requiredCount = this.requiredCount;\n        let generatedData = data.close.map(function (currentData, index) {\n            let i = 0;\n            let returnVal = {\n                open: [],\n                high: [],\n                low: [],\n                close: []\n            };\n            while (i < requiredCount) {\n                returnVal.open.push(data.open[index + i]);\n                returnVal.high.push(data.high[index + i]);\n                returnVal.low.push(data.low[index + i]);\n                returnVal.close.push(data.close[index + i]);\n                i++;\n            }\n            return returnVal;\n        }).filter((val, index) => { return (index <= (data.close.length - requiredCount)); });\n        return generatedData;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}