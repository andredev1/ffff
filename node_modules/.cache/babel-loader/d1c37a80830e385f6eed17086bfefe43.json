{"ast":null,"code":"import { EMA } from '../moving_averages/EMA';\nimport { Indicator, IndicatorInput } from '../indicator/indicator';\nexport class ForceIndexInput extends IndicatorInput {\n  constructor() {\n    super(...arguments);\n    this.period = 1;\n  }\n\n}\n;\nexport class ForceIndex extends Indicator {\n  constructor(input) {\n    super(input);\n    var closes = input.close;\n    var volumes = input.volume;\n    var period = input.period || 1;\n\n    if (!(volumes.length === closes.length)) {\n      throw 'Inputs(volume, close) not of equal size';\n    }\n\n    let emaForceIndex = new EMA({\n      values: [],\n      period: period\n    });\n    this.result = [];\n\n    this.generator = function* () {\n      var previousTick = yield;\n      var tick = yield;\n      let forceIndex;\n\n      while (true) {\n        forceIndex = (tick.close - previousTick.close) * tick.volume;\n        previousTick = tick;\n        tick = yield emaForceIndex.nextValue(forceIndex);\n      }\n    }();\n\n    this.generator.next();\n    volumes.forEach((tick, index) => {\n      var result = this.generator.next({\n        close: closes[index],\n        volume: volumes[index]\n      });\n\n      if (result.value != undefined) {\n        this.result.push(result.value);\n      }\n    });\n  }\n\n  nextValue(price) {\n    let result = this.generator.next(price).value;\n\n    if (result != undefined) {\n      return result;\n    }\n  }\n\n}\nForceIndex.calculate = forceindex;\nexport function forceindex(input) {\n  Indicator.reverseInputs(input);\n  var result = new ForceIndex(input).result;\n\n  if (input.reversedInput) {\n    result.reverse();\n  }\n\n  Indicator.reverseInputs(input);\n  return result;\n}\n;","map":{"version":3,"sources":["/home/andre/Downloads/ffff-main/node_modules/technicalindicators/lib/volume/ForceIndex.js"],"names":["EMA","Indicator","IndicatorInput","ForceIndexInput","constructor","arguments","period","ForceIndex","input","closes","close","volumes","volume","length","emaForceIndex","values","result","generator","previousTick","tick","forceIndex","nextValue","next","forEach","index","value","undefined","push","price","calculate","forceindex","reverseInputs","reversedInput","reverse"],"mappings":"AAAA,SAASA,GAAT,QAAoB,wBAApB;AACA,SAASC,SAAT,EAAoBC,cAApB,QAA0C,wBAA1C;AACA,OAAO,MAAMC,eAAN,SAA8BD,cAA9B,CAA6C;AAChDE,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGC,SAAT;AACA,SAAKC,MAAL,GAAc,CAAd;AACH;;AAJ+C;AAMpD;AACA,OAAO,MAAMC,UAAN,SAAyBN,SAAzB,CAAmC;AACtCG,EAAAA,WAAW,CAACI,KAAD,EAAQ;AACf,UAAMA,KAAN;AACA,QAAIC,MAAM,GAAGD,KAAK,CAACE,KAAnB;AACA,QAAIC,OAAO,GAAGH,KAAK,CAACI,MAApB;AACA,QAAIN,MAAM,GAAGE,KAAK,CAACF,MAAN,IAAgB,CAA7B;;AACA,QAAI,EAAGK,OAAO,CAACE,MAAR,KAAmBJ,MAAM,CAACI,MAA7B,CAAJ,EAA2C;AACvC,YAAO,yCAAP;AACH;;AACD,QAAIC,aAAa,GAAG,IAAId,GAAJ,CAAQ;AAAEe,MAAAA,MAAM,EAAE,EAAV;AAAcT,MAAAA,MAAM,EAAEA;AAAtB,KAAR,CAApB;AACA,SAAKU,MAAL,GAAc,EAAd;;AACA,SAAKC,SAAL,GAAkB,aAAa;AAC3B,UAAIC,YAAY,GAAG,KAAnB;AACA,UAAIC,IAAI,GAAG,KAAX;AACA,UAAIC,UAAJ;;AACA,aAAO,IAAP,EAAa;AACTA,QAAAA,UAAU,GAAG,CAACD,IAAI,CAACT,KAAL,GAAaQ,YAAY,CAACR,KAA3B,IAAoCS,IAAI,CAACP,MAAtD;AACAM,QAAAA,YAAY,GAAGC,IAAf;AACAA,QAAAA,IAAI,GAAG,MAAML,aAAa,CAACO,SAAd,CAAwBD,UAAxB,CAAb;AACH;AACJ,KATgB,EAAjB;;AAUA,SAAKH,SAAL,CAAeK,IAAf;AACAX,IAAAA,OAAO,CAACY,OAAR,CAAgB,CAACJ,IAAD,EAAOK,KAAP,KAAiB;AAC7B,UAAIR,MAAM,GAAG,KAAKC,SAAL,CAAeK,IAAf,CAAoB;AAC7BZ,QAAAA,KAAK,EAAED,MAAM,CAACe,KAAD,CADgB;AAE7BZ,QAAAA,MAAM,EAAED,OAAO,CAACa,KAAD;AAFc,OAApB,CAAb;;AAIA,UAAIR,MAAM,CAACS,KAAP,IAAgBC,SAApB,EAA+B;AAC3B,aAAKV,MAAL,CAAYW,IAAZ,CAAiBX,MAAM,CAACS,KAAxB;AACH;AACJ,KARD;AASH;;AAGDJ,EAAAA,SAAS,CAACO,KAAD,EAAQ;AACb,QAAIZ,MAAM,GAAG,KAAKC,SAAL,CAAeK,IAAf,CAAoBM,KAApB,EAA2BH,KAAxC;;AACA,QAAIT,MAAM,IAAIU,SAAd,EAAyB;AACrB,aAAOV,MAAP;AACH;AACJ;;AAvCqC;AA0C1CT,UAAU,CAACsB,SAAX,GAAuBC,UAAvB;AACA,OAAO,SAASA,UAAT,CAAoBtB,KAApB,EAA2B;AAC9BP,EAAAA,SAAS,CAAC8B,aAAV,CAAwBvB,KAAxB;AACA,MAAIQ,MAAM,GAAG,IAAIT,UAAJ,CAAeC,KAAf,EAAsBQ,MAAnC;;AACA,MAAIR,KAAK,CAACwB,aAAV,EAAyB;AACrBhB,IAAAA,MAAM,CAACiB,OAAP;AACH;;AACDhC,EAAAA,SAAS,CAAC8B,aAAV,CAAwBvB,KAAxB;AACA,SAAOQ,MAAP;AACH;AACD","sourcesContent":["import { EMA } from '../moving_averages/EMA';\nimport { Indicator, IndicatorInput } from '../indicator/indicator';\nexport class ForceIndexInput extends IndicatorInput {\n    constructor() {\n        super(...arguments);\n        this.period = 1;\n    }\n}\n;\nexport class ForceIndex extends Indicator {\n    constructor(input) {\n        super(input);\n        var closes = input.close;\n        var volumes = input.volume;\n        var period = input.period || 1;\n        if (!((volumes.length === closes.length))) {\n            throw ('Inputs(volume, close) not of equal size');\n        }\n        let emaForceIndex = new EMA({ values: [], period: period });\n        this.result = [];\n        this.generator = (function* () {\n            var previousTick = yield;\n            var tick = yield;\n            let forceIndex;\n            while (true) {\n                forceIndex = (tick.close - previousTick.close) * tick.volume;\n                previousTick = tick;\n                tick = yield emaForceIndex.nextValue(forceIndex);\n            }\n        })();\n        this.generator.next();\n        volumes.forEach((tick, index) => {\n            var result = this.generator.next({\n                close: closes[index],\n                volume: volumes[index]\n            });\n            if (result.value != undefined) {\n                this.result.push(result.value);\n            }\n        });\n    }\n    ;\n    ;\n    nextValue(price) {\n        let result = this.generator.next(price).value;\n        if (result != undefined) {\n            return result;\n        }\n    }\n    ;\n}\nForceIndex.calculate = forceindex;\nexport function forceindex(input) {\n    Indicator.reverseInputs(input);\n    var result = new ForceIndex(input).result;\n    if (input.reversedInput) {\n        result.reverse();\n    }\n    Indicator.reverseInputs(input);\n    return result;\n}\n;\n"]},"metadata":{},"sourceType":"module"}