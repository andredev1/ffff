{"ast":null,"code":"import { Indicator, IndicatorInput } from '../indicator/indicator';\nexport class AvgLossInput extends IndicatorInput {}\nexport class AverageLoss extends Indicator {\n  constructor(input) {\n    super(input);\n    let values = input.values;\n    let period = input.period;\n    let format = this.format;\n\n    this.generator = function* (period) {\n      var currentValue = yield;\n      var counter = 1;\n      var lossSum = 0;\n      var avgLoss;\n      var loss;\n      var lastValue = currentValue;\n      currentValue = yield;\n\n      while (true) {\n        loss = lastValue - currentValue;\n        loss = loss > 0 ? loss : 0;\n\n        if (loss > 0) {\n          lossSum = lossSum + loss;\n        }\n\n        if (counter < period) {\n          counter++;\n        } else if (avgLoss === undefined) {\n          avgLoss = lossSum / period;\n        } else {\n          avgLoss = (avgLoss * (period - 1) + loss) / period;\n        }\n\n        lastValue = currentValue;\n        avgLoss = avgLoss !== undefined ? format(avgLoss) : undefined;\n        currentValue = yield avgLoss;\n      }\n    }(period);\n\n    this.generator.next();\n    this.result = [];\n    values.forEach(tick => {\n      var result = this.generator.next(tick);\n\n      if (result.value !== undefined) {\n        this.result.push(result.value);\n      }\n    });\n  }\n\n  nextValue(price) {\n    return this.generator.next(price).value;\n  }\n\n}\nAverageLoss.calculate = averageloss;\nexport function averageloss(input) {\n  Indicator.reverseInputs(input);\n  var result = new AverageLoss(input).result;\n\n  if (input.reversedInput) {\n    result.reverse();\n  }\n\n  Indicator.reverseInputs(input);\n  return result;\n}\n;","map":{"version":3,"sources":["/home/andre/Documents/ffff/node_modules/technicalindicators/lib/Utils/AverageLoss.js"],"names":["Indicator","IndicatorInput","AvgLossInput","AverageLoss","constructor","input","values","period","format","generator","currentValue","counter","lossSum","avgLoss","loss","lastValue","undefined","next","result","forEach","tick","value","push","nextValue","price","calculate","averageloss","reverseInputs","reversedInput","reverse"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,cAApB,QAA0C,wBAA1C;AACA,OAAO,MAAMC,YAAN,SAA2BD,cAA3B,CAA0C;AAEjD,OAAO,MAAME,WAAN,SAA0BH,SAA1B,CAAoC;AACvCI,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AACA,QAAIC,MAAM,GAAGD,KAAK,CAACC,MAAnB;AACA,QAAIC,MAAM,GAAGF,KAAK,CAACE,MAAnB;AACA,QAAIC,MAAM,GAAG,KAAKA,MAAlB;;AACA,SAAKC,SAAL,GAAkB,WAAWF,MAAX,EAAmB;AACjC,UAAIG,YAAY,GAAG,KAAnB;AACA,UAAIC,OAAO,GAAG,CAAd;AACA,UAAIC,OAAO,GAAG,CAAd;AACA,UAAIC,OAAJ;AACA,UAAIC,IAAJ;AACA,UAAIC,SAAS,GAAGL,YAAhB;AACAA,MAAAA,YAAY,GAAG,KAAf;;AACA,aAAO,IAAP,EAAa;AACTI,QAAAA,IAAI,GAAGC,SAAS,GAAGL,YAAnB;AACAI,QAAAA,IAAI,GAAGA,IAAI,GAAG,CAAP,GAAWA,IAAX,GAAkB,CAAzB;;AACA,YAAIA,IAAI,GAAG,CAAX,EAAc;AACVF,UAAAA,OAAO,GAAGA,OAAO,GAAGE,IAApB;AACH;;AACD,YAAIH,OAAO,GAAGJ,MAAd,EAAsB;AAClBI,UAAAA,OAAO;AACV,SAFD,MAGK,IAAIE,OAAO,KAAKG,SAAhB,EAA2B;AAC5BH,UAAAA,OAAO,GAAGD,OAAO,GAAGL,MAApB;AACH,SAFI,MAGA;AACDM,UAAAA,OAAO,GAAG,CAAEA,OAAO,IAAIN,MAAM,GAAG,CAAb,CAAR,GAA2BO,IAA5B,IAAoCP,MAA9C;AACH;;AACDQ,QAAAA,SAAS,GAAGL,YAAZ;AACAG,QAAAA,OAAO,GAAIA,OAAO,KAAKG,SAAb,GAA0BR,MAAM,CAACK,OAAD,CAAhC,GAA4CG,SAAtD;AACAN,QAAAA,YAAY,GAAG,MAAMG,OAArB;AACH;AACJ,KA3BgB,CA2BdN,MA3Bc,CAAjB;;AA4BA,SAAKE,SAAL,CAAeQ,IAAf;AACA,SAAKC,MAAL,GAAc,EAAd;AACAZ,IAAAA,MAAM,CAACa,OAAP,CAAgBC,IAAD,IAAU;AACrB,UAAIF,MAAM,GAAG,KAAKT,SAAL,CAAeQ,IAAf,CAAoBG,IAApB,CAAb;;AACA,UAAIF,MAAM,CAACG,KAAP,KAAiBL,SAArB,EAAgC;AAC5B,aAAKE,MAAL,CAAYI,IAAZ,CAAiBJ,MAAM,CAACG,KAAxB;AACH;AACJ,KALD;AAMH;;AACDE,EAAAA,SAAS,CAACC,KAAD,EAAQ;AACb,WAAO,KAAKf,SAAL,CAAeQ,IAAf,CAAoBO,KAApB,EAA2BH,KAAlC;AACH;;AA7CsC;AAgD3ClB,WAAW,CAACsB,SAAZ,GAAwBC,WAAxB;AACA,OAAO,SAASA,WAAT,CAAqBrB,KAArB,EAA4B;AAC/BL,EAAAA,SAAS,CAAC2B,aAAV,CAAwBtB,KAAxB;AACA,MAAIa,MAAM,GAAG,IAAIf,WAAJ,CAAgBE,KAAhB,EAAuBa,MAApC;;AACA,MAAIb,KAAK,CAACuB,aAAV,EAAyB;AACrBV,IAAAA,MAAM,CAACW,OAAP;AACH;;AACD7B,EAAAA,SAAS,CAAC2B,aAAV,CAAwBtB,KAAxB;AACA,SAAOa,MAAP;AACH;AACD","sourcesContent":["import { Indicator, IndicatorInput } from '../indicator/indicator';\nexport class AvgLossInput extends IndicatorInput {\n}\nexport class AverageLoss extends Indicator {\n    constructor(input) {\n        super(input);\n        let values = input.values;\n        let period = input.period;\n        let format = this.format;\n        this.generator = (function* (period) {\n            var currentValue = yield;\n            var counter = 1;\n            var lossSum = 0;\n            var avgLoss;\n            var loss;\n            var lastValue = currentValue;\n            currentValue = yield;\n            while (true) {\n                loss = lastValue - currentValue;\n                loss = loss > 0 ? loss : 0;\n                if (loss > 0) {\n                    lossSum = lossSum + loss;\n                }\n                if (counter < period) {\n                    counter++;\n                }\n                else if (avgLoss === undefined) {\n                    avgLoss = lossSum / period;\n                }\n                else {\n                    avgLoss = ((avgLoss * (period - 1)) + loss) / period;\n                }\n                lastValue = currentValue;\n                avgLoss = (avgLoss !== undefined) ? format(avgLoss) : undefined;\n                currentValue = yield avgLoss;\n            }\n        })(period);\n        this.generator.next();\n        this.result = [];\n        values.forEach((tick) => {\n            var result = this.generator.next(tick);\n            if (result.value !== undefined) {\n                this.result.push(result.value);\n            }\n        });\n    }\n    nextValue(price) {\n        return this.generator.next(price).value;\n    }\n    ;\n}\nAverageLoss.calculate = averageloss;\nexport function averageloss(input) {\n    Indicator.reverseInputs(input);\n    var result = new AverageLoss(input).result;\n    if (input.reversedInput) {\n        result.reverse();\n    }\n    Indicator.reverseInputs(input);\n    return result;\n}\n;\n"]},"metadata":{},"sourceType":"module"}