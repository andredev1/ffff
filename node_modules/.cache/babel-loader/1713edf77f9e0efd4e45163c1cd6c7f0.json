{"ast":null,"code":"/**\n * Created by AAravindan on 5/5/16.\n */\nimport { Indicator, IndicatorInput } from '../indicator/indicator';\nimport { AverageGain } from '../Utils/AverageGain';\nimport { AverageLoss } from '../Utils/AverageLoss';\nexport class RSIInput extends IndicatorInput {}\nexport class RSI extends Indicator {\n  constructor(input) {\n    super(input);\n    var period = input.period;\n    var values = input.values;\n    var GainProvider = new AverageGain({\n      period: period,\n      values: []\n    });\n    var LossProvider = new AverageLoss({\n      period: period,\n      values: []\n    });\n    let count = 1;\n\n    this.generator = function* (period) {\n      var current = yield;\n      var lastAvgGain, lastAvgLoss, RS, currentRSI;\n\n      while (true) {\n        lastAvgGain = GainProvider.nextValue(current);\n        lastAvgLoss = LossProvider.nextValue(current);\n\n        if (lastAvgGain !== undefined && lastAvgLoss !== undefined) {\n          if (lastAvgLoss === 0) {\n            currentRSI = 100;\n          } else if (lastAvgGain === 0) {\n            currentRSI = 0;\n          } else {\n            RS = lastAvgGain / lastAvgLoss;\n            RS = isNaN(RS) ? 0 : RS;\n            currentRSI = parseFloat((100 - 100 / (1 + RS)).toFixed(2));\n          }\n        }\n\n        count++;\n        current = yield currentRSI;\n      }\n    }(period);\n\n    this.generator.next();\n    this.result = [];\n    values.forEach(tick => {\n      var result = this.generator.next(tick);\n\n      if (result.value !== undefined) {\n        this.result.push(result.value);\n      }\n    });\n  }\n\n  nextValue(price) {\n    return this.generator.next(price).value;\n  }\n\n}\nRSI.calculate = rsi;\nexport function rsi(input) {\n  Indicator.reverseInputs(input);\n  var result = new RSI(input).result;\n\n  if (input.reversedInput) {\n    result.reverse();\n  }\n\n  Indicator.reverseInputs(input);\n  return result;\n}\n;","map":{"version":3,"sources":["/home/andre/Documents/f/f/node_modules/technicalindicators/lib/oscillators/RSI.js"],"names":["Indicator","IndicatorInput","AverageGain","AverageLoss","RSIInput","RSI","constructor","input","period","values","GainProvider","LossProvider","count","generator","current","lastAvgGain","lastAvgLoss","RS","currentRSI","nextValue","undefined","isNaN","parseFloat","toFixed","next","result","forEach","tick","value","push","price","calculate","rsi","reverseInputs","reversedInput","reverse"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,SAAT,EAAoBC,cAApB,QAA0C,wBAA1C;AACA,SAASC,WAAT,QAA4B,sBAA5B;AACA,SAASC,WAAT,QAA4B,sBAA5B;AACA,OAAO,MAAMC,QAAN,SAAuBH,cAAvB,CAAsC;AAE7C,OAAO,MAAMI,GAAN,SAAkBL,SAAlB,CAA4B;AAC/BM,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AACA,QAAIC,MAAM,GAAGD,KAAK,CAACC,MAAnB;AACA,QAAIC,MAAM,GAAGF,KAAK,CAACE,MAAnB;AACA,QAAIC,YAAY,GAAG,IAAIR,WAAJ,CAAgB;AAAEM,MAAAA,MAAM,EAAEA,MAAV;AAAkBC,MAAAA,MAAM,EAAE;AAA1B,KAAhB,CAAnB;AACA,QAAIE,YAAY,GAAG,IAAIR,WAAJ,CAAgB;AAAEK,MAAAA,MAAM,EAAEA,MAAV;AAAkBC,MAAAA,MAAM,EAAE;AAA1B,KAAhB,CAAnB;AACA,QAAIG,KAAK,GAAG,CAAZ;;AACA,SAAKC,SAAL,GAAkB,WAAWL,MAAX,EAAmB;AACjC,UAAIM,OAAO,GAAG,KAAd;AACA,UAAIC,WAAJ,EAAiBC,WAAjB,EAA8BC,EAA9B,EAAkCC,UAAlC;;AACA,aAAO,IAAP,EAAa;AACTH,QAAAA,WAAW,GAAGL,YAAY,CAACS,SAAb,CAAuBL,OAAvB,CAAd;AACAE,QAAAA,WAAW,GAAGL,YAAY,CAACQ,SAAb,CAAuBL,OAAvB,CAAd;;AACA,YAAKC,WAAW,KAAKK,SAAjB,IAAgCJ,WAAW,KAAKI,SAApD,EAAgE;AAC5D,cAAIJ,WAAW,KAAK,CAApB,EAAuB;AACnBE,YAAAA,UAAU,GAAG,GAAb;AACH,WAFD,MAGK,IAAIH,WAAW,KAAK,CAApB,EAAuB;AACxBG,YAAAA,UAAU,GAAG,CAAb;AACH,WAFI,MAGA;AACDD,YAAAA,EAAE,GAAGF,WAAW,GAAGC,WAAnB;AACAC,YAAAA,EAAE,GAAGI,KAAK,CAACJ,EAAD,CAAL,GAAY,CAAZ,GAAgBA,EAArB;AACAC,YAAAA,UAAU,GAAGI,UAAU,CAAC,CAAC,MAAO,OAAO,IAAIL,EAAX,CAAR,EAAyBM,OAAzB,CAAiC,CAAjC,CAAD,CAAvB;AACH;AACJ;;AACDX,QAAAA,KAAK;AACLE,QAAAA,OAAO,GAAG,MAAMI,UAAhB;AACH;AACJ,KAtBgB,CAsBdV,MAtBc,CAAjB;;AAuBA,SAAKK,SAAL,CAAeW,IAAf;AACA,SAAKC,MAAL,GAAc,EAAd;AACAhB,IAAAA,MAAM,CAACiB,OAAP,CAAgBC,IAAD,IAAU;AACrB,UAAIF,MAAM,GAAG,KAAKZ,SAAL,CAAeW,IAAf,CAAoBG,IAApB,CAAb;;AACA,UAAIF,MAAM,CAACG,KAAP,KAAiBR,SAArB,EAAgC;AAC5B,aAAKK,MAAL,CAAYI,IAAZ,CAAiBJ,MAAM,CAACG,KAAxB;AACH;AACJ,KALD;AAMH;;AAEDT,EAAAA,SAAS,CAACW,KAAD,EAAQ;AACb,WAAO,KAAKjB,SAAL,CAAeW,IAAf,CAAoBM,KAApB,EAA2BF,KAAlC;AACH;;AA3C8B;AA8CnCvB,GAAG,CAAC0B,SAAJ,GAAgBC,GAAhB;AACA,OAAO,SAASA,GAAT,CAAazB,KAAb,EAAoB;AACvBP,EAAAA,SAAS,CAACiC,aAAV,CAAwB1B,KAAxB;AACA,MAAIkB,MAAM,GAAG,IAAIpB,GAAJ,CAAQE,KAAR,EAAekB,MAA5B;;AACA,MAAIlB,KAAK,CAAC2B,aAAV,EAAyB;AACrBT,IAAAA,MAAM,CAACU,OAAP;AACH;;AACDnC,EAAAA,SAAS,CAACiC,aAAV,CAAwB1B,KAAxB;AACA,SAAOkB,MAAP;AACH;AACD","sourcesContent":["/**\n * Created by AAravindan on 5/5/16.\n */\nimport { Indicator, IndicatorInput } from '../indicator/indicator';\nimport { AverageGain } from '../Utils/AverageGain';\nimport { AverageLoss } from '../Utils/AverageLoss';\nexport class RSIInput extends IndicatorInput {\n}\nexport class RSI extends Indicator {\n    constructor(input) {\n        super(input);\n        var period = input.period;\n        var values = input.values;\n        var GainProvider = new AverageGain({ period: period, values: [] });\n        var LossProvider = new AverageLoss({ period: period, values: [] });\n        let count = 1;\n        this.generator = (function* (period) {\n            var current = yield;\n            var lastAvgGain, lastAvgLoss, RS, currentRSI;\n            while (true) {\n                lastAvgGain = GainProvider.nextValue(current);\n                lastAvgLoss = LossProvider.nextValue(current);\n                if ((lastAvgGain !== undefined) && (lastAvgLoss !== undefined)) {\n                    if (lastAvgLoss === 0) {\n                        currentRSI = 100;\n                    }\n                    else if (lastAvgGain === 0) {\n                        currentRSI = 0;\n                    }\n                    else {\n                        RS = lastAvgGain / lastAvgLoss;\n                        RS = isNaN(RS) ? 0 : RS;\n                        currentRSI = parseFloat((100 - (100 / (1 + RS))).toFixed(2));\n                    }\n                }\n                count++;\n                current = yield currentRSI;\n            }\n        })(period);\n        this.generator.next();\n        this.result = [];\n        values.forEach((tick) => {\n            var result = this.generator.next(tick);\n            if (result.value !== undefined) {\n                this.result.push(result.value);\n            }\n        });\n    }\n    ;\n    nextValue(price) {\n        return this.generator.next(price).value;\n    }\n    ;\n}\nRSI.calculate = rsi;\nexport function rsi(input) {\n    Indicator.reverseInputs(input);\n    var result = new RSI(input).result;\n    if (input.reversedInput) {\n        result.reverse();\n    }\n    Indicator.reverseInputs(input);\n    return result;\n}\n;\n"]},"metadata":{},"sourceType":"module"}