{"ast":null,"code":"import { IndicatorInput, Indicator } from '../indicator/indicator';\nimport LinkedList from '../Utils/FixedSizeLinkedList';\nexport class WilliamsRInput extends IndicatorInput {}\n;\nexport class WilliamsR extends Indicator {\n  constructor(input) {\n    super(input);\n    let lows = input.low;\n    let highs = input.high;\n    let closes = input.close;\n    let period = input.period;\n    let format = this.format;\n\n    if (!(lows.length === highs.length && highs.length === closes.length)) {\n      throw 'Inputs(low,high, close) not of equal size';\n    }\n\n    this.result = []; //%R = (Highest High - Close)/(Highest High - Lowest Low) * -100\n    //Lowest Low = lowest low for the look-back period\n    //Highest High = highest high for the look-back period\n    //%R is multiplied by -100 correct the inversion and move the decimal.\n\n    this.generator = function* () {\n      let index = 1;\n      let pastHighPeriods = new LinkedList(period, true, false);\n      let pastLowPeriods = new LinkedList(period, false, true);\n      let periodLow;\n      let periodHigh;\n      var tick = yield;\n      let williamsR;\n\n      while (true) {\n        pastHighPeriods.push(tick.high);\n        pastLowPeriods.push(tick.low);\n\n        if (index < period) {\n          index++;\n          tick = yield;\n          continue;\n        }\n\n        periodLow = pastLowPeriods.periodLow;\n        periodHigh = pastHighPeriods.periodHigh;\n        williamsR = format((periodHigh - tick.close) / (periodHigh - periodLow) * -100);\n        tick = yield williamsR;\n      }\n    }();\n\n    this.generator.next();\n    lows.forEach((low, index) => {\n      var result = this.generator.next({\n        high: highs[index],\n        low: lows[index],\n        close: closes[index]\n      });\n\n      if (result.value !== undefined) {\n        this.result.push(result.value);\n      }\n    });\n  }\n\n  nextValue(price) {\n    var nextResult = this.generator.next(price);\n    if (nextResult.value != undefined) return this.format(nextResult.value);\n  }\n\n}\nWilliamsR.calculate = williamsr;\nexport function williamsr(input) {\n  Indicator.reverseInputs(input);\n  var result = new WilliamsR(input).result;\n\n  if (input.reversedInput) {\n    result.reverse();\n  }\n\n  Indicator.reverseInputs(input);\n  return result;\n}\n;","map":{"version":3,"sources":["/home/andre/Documents/f/f/node_modules/technicalindicators/lib/momentum/WilliamsR.js"],"names":["IndicatorInput","Indicator","LinkedList","WilliamsRInput","WilliamsR","constructor","input","lows","low","highs","high","closes","close","period","format","length","result","generator","index","pastHighPeriods","pastLowPeriods","periodLow","periodHigh","tick","williamsR","push","next","forEach","value","undefined","nextValue","price","nextResult","calculate","williamsr","reverseInputs","reversedInput","reverse"],"mappings":"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","sourcesContent":["import { IndicatorInput, Indicator } from '../indicator/indicator';\nimport LinkedList from '../Utils/FixedSizeLinkedList';\nexport class WilliamsRInput extends IndicatorInput {\n}\n;\nexport class WilliamsR extends Indicator {\n    constructor(input) {\n        super(input);\n        let lows = input.low;\n        let highs = input.high;\n        let closes = input.close;\n        let period = input.period;\n        let format = this.format;\n        if (!((lows.length === highs.length) && (highs.length === closes.length))) {\n            throw ('Inputs(low,high, close) not of equal size');\n        }\n        this.result = [];\n        //%R = (Highest High - Close)/(Highest High - Lowest Low) * -100\n        //Lowest Low = lowest low for the look-back period\n        //Highest High = highest high for the look-back period\n        //%R is multiplied by -100 correct the inversion and move the decimal.\n        this.generator = (function* () {\n            let index = 1;\n            let pastHighPeriods = new LinkedList(period, true, false);\n            let pastLowPeriods = new LinkedList(period, false, true);\n            let periodLow;\n            let periodHigh;\n            var tick = yield;\n            let williamsR;\n            while (true) {\n                pastHighPeriods.push(tick.high);\n                pastLowPeriods.push(tick.low);\n                if (index < period) {\n                    index++;\n                    tick = yield;\n                    continue;\n                }\n                periodLow = pastLowPeriods.periodLow;\n                periodHigh = pastHighPeriods.periodHigh;\n                williamsR = format((periodHigh - tick.close) / (periodHigh - periodLow) * -100);\n                tick = yield williamsR;\n            }\n        })();\n        this.generator.next();\n        lows.forEach((low, index) => {\n            var result = this.generator.next({\n                high: highs[index],\n                low: lows[index],\n                close: closes[index]\n            });\n            if (result.value !== undefined) {\n                this.result.push(result.value);\n            }\n        });\n    }\n    ;\n    nextValue(price) {\n        var nextResult = this.generator.next(price);\n        if (nextResult.value != undefined)\n            return this.format(nextResult.value);\n    }\n    ;\n}\nWilliamsR.calculate = williamsr;\nexport function williamsr(input) {\n    Indicator.reverseInputs(input);\n    var result = new WilliamsR(input).result;\n    if (input.reversedInput) {\n        result.reverse();\n    }\n    Indicator.reverseInputs(input);\n    return result;\n}\n;\n"]},"metadata":{},"sourceType":"module"}